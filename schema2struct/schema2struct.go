package main

import (
	"database/sql"
	"fmt"
	"io"
	"os"
	"strings"
	"text/template"

	"github.com/jackson198608/squirrel"
	"github.com/codegangsta/cli"

	_ "github.com/lib/pq"
)

const version = "DEV"

const Usage = `Read a schema and generate Structable structs.

This utility generates Structable structs be reading your database table and
generating the appropriate code.
`

const fileHeader = `package %s

// This file is automatically generated by schema2struct.

import (
	"time"

	"github.com/jackson198608/squirrel"
	"github.com/jackson198608/structable"
	_ "github.com/lib/pq"
)

// QueryFunc modifies a SelectBuilder prior to execution.
//
// The SelectBuilder is modified in place. An error is returned under any
// conditions where the query should not be executed.
type QueryFunc func(q squirrel.SelectBuilder) (squirrel.SelectBuilder, error)

`

const structTemplate = `// {{.StructName}} maps to database table {{.TableName}}
type {{.StructName}} struct {
	tableName string {{ann "tablename" .TableName}}
	structable.Recorder
	builder squirrel.StatementBuilderType
	{{range .Fields}}{{.}}
	{{end}}db squirrel.DBProxyBeginner
	flavor string
}

// New{{.StructName}} creates a new {{.StructName}} wired to structable.
func New{{.StructName}}(db squirrel.DBProxyBeginner, flavor string) *{{.StructName}} {
	o := &{{.StructName}}{db: db, flavor: flavor}
	o.Recorder = structable.New(db, flavor).Bind("{{.TableName}}", o)
	return o
}

// List{{.StructName}} returns a list of {{.StructName}} objects.
//
// Limit is the max number of items. Offset is the offset the results will
// begin with.
func List{{.StructName}}(db squirrel.DBProxyBeginner, flavor string, limit, offset uint64) ([]*{{.StructName}}, error) {
	fn := func(q squirrel.SelectBuilder) (squirrel.SelectBuilder, error) {
		return q.Limit(limit).Offset(offset), nil
	}
	return Query{{.StructName}}(db, flavor, fn)
}

// Query{{.StructName}} builds a base query, but allows the query to be modified before execution.
//
// This creates a new Select, settings the columns and table name, and then calling QueryFunc with the
// query. The QueryFunc can then add a Where clause, etc. Provided QueryFunc does not exit with an
// error, Query{{.StructName}} will then execute the query, extract the results into a slice of
// {{.StructName}} structs, and then return.
//
// The QueryFunc should not modify the list of fields returned or the table name,
// as the intent is to construct a complete {{.StructName}} from each result.
// More sophisticated queries should be written directly.
func Query{{.StructName}}(db squirrel.DBProxyBeginner, flavor string, fn QueryFunc) ([]*{{.StructName}}, error){
	var tn string = "{{.TableName}}"

	// We need a prototype structable to learn about the table structure.
	ps := New{{.StructName}}(db, flavor)
	cols := ps.Columns(true)

	q := ps.Builder().Select(cols...).From(tn)
	var err error
	if q, err = fn(q); err != nil {
		return []*{{.StructName}}{}, err
	}
	rows, err := q.Query()
	if err != nil || rows == nil {
		return []*{{.StructName}}{}, err
	}
	defer rows.Close()

	buf := []*{{.StructName}}{}
	for rows.Next() {
		o := New{{.StructName}}(db, flavor)
		dest := o.FieldReferences(true)
		if err := rows.Scan(dest...); err != nil {
			return buf, err
		}
		buf = append(buf, o)
	}
	return buf, rows.Err()
}

// Len{{.StructName}} returns the number of {{.StructName}} objects in the database.
func Len{{.StructName}}(db squirrel.DBProxyBeginner, flavor string) (int, error) {
	fn := func(q squirrel.SelectBuilder) (squirrel.SelectBuilder, error) {return q, nil}
	return QueryLen{{.StructName}}(db, flavor, fn)
}

// QueryLen{{.StructName}} returns the length of a table.
//
// The QueryFunc can be used to modify the query. For a simple length call, you
// may prefer to use Len{{.StructName}}.
func QueryLen{{.StructName}}(db squirrel.DBProxyBeginner, flavor string, fn QueryFunc) (int, error) {
	tn := "{{.TableName}}"
	ps := New{{.StructName}}(db, flavor)
	q := ps.Builder().Select("COUNT(*)").From(tn)
	var err error
	if q, err = fn(q); err != nil {
		return 0, err
	}
	var count int
	err = q.Scan(&count)
	return count, err
}

`

type structDesc struct {
	StructName string
	TableName  string
	Fields     []string
}

func main() {
	app := cli.NewApp()
	app.Name = "schema2struct"
	app.Version = "version"
	app.Usage = Usage
	app.Action = importTables
	app.Flags = []cli.Flag{
		cli.StringFlag{
			Name:  "driver,d",
			Value: "postgres",
			Usage: "The name of the SQL driver to use.",
		},
		cli.StringFlag{
			Name:  "connection,c",
			Value: "user=$USER dbname=$USER sslmode=disable",
			Usage: "The database connection string. Environment variables are expanded.",
		},
		cli.StringFlag{
			Name:  "tables,t",
			Value: "",
			Usage: "The list of tables to generate, comma separated. If none specified, the entire schema is used.",
		},
		cli.StringFlag{
			Name:  "file,f",
			Value: "",
			Usage: "The file to send the output.",
		},
		cli.StringFlag{
			Name:   "package,p",
			Value:  "main",
			Usage:  "The name of the destination package.",
			EnvVar: "GOPACKAGE",
		},
	}

	app.Run(os.Args)
}

func driver(c *cli.Context) string {
	return c.String("driver")
}
func conn(c *cli.Context) string {
	return os.ExpandEnv(c.String("connection"))
}

// dest gets the destination output writer.
func dest(c *cli.Context) io.Writer {
	if out := c.String("file"); out != "" {
		f, err := os.Create(out)
		if err != nil {
			panic(f)
		}
		return f
	}
	return os.Stdout
}

func tableList(c *cli.Context) []string {
	z := c.String("tables")
	if z != "" {
		return strings.Split(z, ",")
	}
	return []string{}
}

func cxdie(c *cli.Context, err error) {
	fmt.Fprintf(os.Stderr, "Failed to connect to %s (type %s): %s", conn(c), driver(c), err)
	os.Exit(1)
}

var funcMap = map[string]interface{}{
	"ann": func(tag, val string) string {
		return fmt.Sprintf("`%s:\"%s\"`", tag, val)
	},
}

func importTables(c *cli.Context) {
	ttt := template.Must(template.New("st").Funcs(funcMap).Parse(structTemplate))
	cxn, err := sql.Open(driver(c), conn(c))
	if err != nil {
		cxdie(c, err)
	}
	// Many drivers defer connections until the first statement. We test
	// that here.
	if err := cxn.Ping(); err != nil {
		cxdie(c, err)
	}
	defer cxn.Close()

	// Set up Squirrel
	stmts := squirrel.NewStmtCacher(cxn)
	bldr := squirrel.StatementBuilder.RunWith(stmts)
	if driver(c) == "postgres" {
		bldr = bldr.PlaceholderFormat(squirrel.Dollar)
	}

	// Set up destination
	out := dest(c)
	fmt.Fprintf(out, fileHeader, c.String("package"))

	tables := tableList(c)

	if len(tables) == 0 {
		tables, err = publicTables(bldr)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Cannot fetch list of tables: %s\n", err)
			os.Exit(2)
		}
	}

	for _, t := range tables {
		f, err := importTable(t, bldr)
		if err != nil {
			fmt.Fprintf(os.Stderr, "Failed to import table %s: %s", t, err)
		}

		//fmt.Fprintf(out, "%s %s %s\n", f.StructName, f.TableName, f.Fields)
		ttt.Execute(out, f)
	}
}

type column struct {
	Name, DataType string
	Max            int64
}

func publicTables(b squirrel.StatementBuilderType) ([]string, error) {
	rows, err := b.Select("table_name").From("INFORMATION_SCHEMA.TABLES").
		Where("table_schema = 'public'").Query()

	res := []string{}
	if err != nil {
		return res, err
	}

	for rows.Next() {
		var s string
		rows.Scan(&s)
		res = append(res, s)
	}

	return res, nil
}

// importTable reads a table definition and writes a corresponding struct.
// SELECT table_name, column_name, data_type, character_maximum_length
//   FROM INFORMATION_SCHEMA.COLUMNS WHERE table_name = 'goose_db_version'
func importTable(tbl string, b squirrel.StatementBuilderType) (*structDesc, error) {

	pks, err := primaryKeyField(tbl, b)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error getting primary keys: %s", err)
	}

	q := b.Select("column_name, data_type, character_maximum_length").
		From("INFORMATION_SCHEMA.COLUMNS").
		Where("table_name = ?", tbl)

	rows, err := q.Query()
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	ff := []string{}
	for rows.Next() {
		c := &column{}
		var length sql.NullInt64
		if err := rows.Scan(&c.Name, &c.DataType, &length); err != nil {
			return nil, err
		}
		c.Max = length.Int64
		ff = append(ff, structField(c, pks, tbl, b))
	}
	sd := &structDesc{
		StructName: goName(tbl),
		TableName:  tbl,
		Fields:     ff,
	}

	return sd, nil
}

func primaryKeyField(tbl string, b squirrel.StatementBuilderType) ([]string, error) {
	q := b.Select("column_name").
		From("INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS c").
		LeftJoin("INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS t USING(constraint_name)").
		Where("t.table_name = ? AND t.constraint_type = 'PRIMARY KEY'", tbl).
		OrderBy("ordinal_position")

	rows, err := q.Query()
	if err != nil {
		return []string{}, err
	}

	res := []string{}
	for rows.Next() {
		var s string
		rows.Scan(&s)
		res = append(res, s)
	}
	return res, nil
}

func sequentialKey(tbl, pk string, b squirrel.StatementBuilderType) bool {

	tlen := 58

	stbl := tbl
	if len(tbl) > 29 {
		stbl = tbl[0:29]
	}

	left := tlen - len(stbl)
	spk := pk
	if len(pk) > left {
		spk = pk[0:left]
	}
	seq := fmt.Sprintf("%s_%s_seq", stbl, spk)

	q := b.Select("COUNT(*)").
		From("INFORMATION_SCHEMA.SEQUENCES").
		Where("sequence_name = ?", seq)

	var num int
	if err := q.Scan(&num); err != nil {
		panic(err)
	}
	return num > 0
}

func structField(c *column, pks []string, tbl string, b squirrel.StatementBuilderType) string {
	tpl := "%s %s `stbl:\"%s\"`"
	gn := destutter(goName(c.Name), goName(tbl))
	tt := goType(c.DataType)

	tag := c.Name
	for _, p := range pks {
		if c.Name == p {
			tag += ",PRIMARY_KEY"
			if sequentialKey(tbl, c.Name, b) {
				tag += ",SERIAL"
			}
		}
	}

	return fmt.Sprintf(tpl, gn, tt, tag)
}

// goType takes a SQL type and returns a string containin the name of a Go type.
//
// The goal is not to provide an exact match for every type, but to provide a
// safe Go representation of a SQL type.
//
// For some floating point SQL types, for example, we store them as strings
// so as not to lose precision while also not adding new types.
//
// The default type is string.
func goType(sqlType string) string {
	switch sqlType {
	case "smallint", "smallserial":
		return "int16"
	case "integer", "serial":
		return "int32"
	case "bigint", "bigserial":
		return "int"
	case "real":
		return "float32"
	case "double precision":
		return "float64"
	// Because we need to preserve base-10 precision.
	case "money":
		return "string"
	case "text", "varchar", "char", "character", "character varying", "uuid":
		return "string"
	case "bytea":
		return "[]byte"
	case "boolean":
		return "bool"
	case "timezone", "timezonetz", "date", "time":
		return "time.Time"
	case "interval":
		return "time.Duration"
	}
	return "string"
}

// Convert a SQL name to a Go name.
func goName(sqlName string) string {
	// This can definitely be done better.
	goName := strings.Replace(sqlName, "_", " ", -1)
	goName = strings.Replace(goName, ".", " ", -1)
	goName = strings.Title(goName)
	goName = strings.Replace(goName, " ", "", -1)

	return goName
}

// destutter removes a stutter prefix.
func destutter(str, prefix string) string {
	return strings.TrimPrefix(str, prefix)
}
